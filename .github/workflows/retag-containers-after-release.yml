# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: Update semantic tags on repo & image after release

on:
  push:
    tags:
      - "v[0-9]+.[0-9]+.[0-9]+"

concurrency:
  group: "${{ github.workflow }}"
  cancel-in-progress: false # last one must win in case of multiple releases

permissions:
  contents: write
  packages: write

env:
  CARGO_TERM_COLOR: always
  # Use docker.io for Docker Hub if empty
  REGISTRY: ghcr.io
  # github.repository as <account>/<repo>
  IMAGE_NAME: ${{ github.repository }}

jobs:
  repo-has-container:
    name: Repo has container?
    runs-on: ubuntu-latest
    outputs:
      has_container: ${{ steps.determine.outputs.has_container }}

    steps:
      - name: Repo has docker container?
        id: determine
        shell: bash
        run: |
          has_container="${{ vars.HAS_CONTAINER }}"
          echo "has_container=${has_container:-false}" >> ${GITHUB_OUTPUT}

  retag-containers:
    name: Retag the containers
    runs-on: ubuntu-latest
    needs:
      - repo-has-container
    if: |
      fromJSON(needs.repo-has-container.outputs.has_container) == true
    steps:
      - name: Download crane tar, extract, and add folder to path.
        shell: bash
        run: |
          # name of the file in releases we're looking for
          file_name=go-containerregistry_Linux_x86_64.tar.gz

          # temp location
          temp_path=$(mktemp --directory --tmpdir=${RUNNER_TEMP})

          # where to download the releases to
          json_path=${temp_path}/releases.json

          # where to download the archive to
          archive_path=${temp_path}/${file_name}

          url_to_krane=$(wget \
              --output-document=- \
              --timeout=10 \
              --waitretry=3 \
              --retry-connrefused \
              --progress=dot:mega \
              "https://api.github.com/repos/google/go-containerregistry/releases/latest" \
              | jq \
                  --raw-output \
                  ".assets.[] | select(.browser_download_url | contains(\"${file_name}\")) | .browser_download_url")

          wget \
            --output-document=- \
            --timeout=10 \
            --waitretry=3 \
            --retry-connrefused \
            --progress=dot:mega \
            "${url_to_krane}" \
            | tar \
                --directory=${temp_path}/ \
                --strip-components=0 \
                --no-overwrite-dir \
                --extract \
                --verbose \
                --gunzip \
                --file=-

          # append to path
          echo "${temp_path}" >> ${GITHUB_PATH}

      - name: Set up Docker
        uses: docker/setup-docker-action@e61617a16c407a86262fb923c35a616ddbe070b3 # v4.6.0
        with:
          daemon-config: |
            {
              "features": {
                "containerd-snapshotter": true
              }
            }

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      - name: Log into registry ${{ env.REGISTRY }}
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          password: ${{ secrets.GITHUB_TOKEN }}
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}

      - name: Set full image name
        shell: bash
        run: |
          echo "FULL_IMAGE_NAME=${REGISTRY,,}/${IMAGE_NAME,,}" >> ${GITHUB_ENV}

      - name: Find all tags for ${{ env.FULL_IMAGE_NAME }}
        shell: bash
        run: |
          crane ls ${FULL_IMAGE_NAME} >> existing_tags

          echo "These are the existing tags on ${FULL_IMAGE_NAME}:"
          cat existing_tags

      - name: Check if the incoming PR has a Docker container, which will be our old tag
        shell: bash
        run: |
          old_tag=$(cat existing_tags | grep "^sha-${{ github.sha }}-.*\$") # .* is actual or retag

          echo "OLD_TAG=${old_tag}" >> ${GITHUB_ENV}

      - name: Set the new TAGs
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5.10.0
        with:
          images: "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          tags: |
            type=raw,value=latest
            type=semver,pattern=v{{version}}

      - name: Actually re-tag the container
        shell: bash
        run: |
          echo "${{ steps.meta.outputs.tags }}" | while read new_tag
          do
            docker buildx imagetools create --tag ${new_tag} "${FULL_IMAGE_NAME}:${OLD_TAG}"
          done
