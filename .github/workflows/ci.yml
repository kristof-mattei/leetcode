# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: CI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

concurrency:
  # each new commit to a PR runs this workflow
  # so we need to avoid a long running older one from overwriting the "pr-<number>-latest"
  group: "${{ github.workflow }} @ ${{ github.ref_name }}"
  cancel-in-progress: true

permissions:
  contents: read

env:
  CARGO_TERM_COLOR: always
  # github.repository as <account>/<repo>
  IMAGE_NAME: ${{ github.repository }}
  IMAGE_VARIANTS: |-
    arm64
    amd64
    amd64/v2
    amd64/v3
  # Use docker.io for Docker Hub if empty
  REGISTRY: ghcr.io

jobs:
  architectures:
    name: Build matrix
    runs-on: ubuntu-slim
    outputs:
      architectures: ${{ steps.matrix.outputs.architectures }}
    steps:
      - name: Build matrix
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        id: matrix
        with:
          script: |
            const architectures = process.env.IMAGE_VARIANTS.trim().split("\n").map((a) => a.trim());

            const json = JSON.stringify(architectures);

            core.setOutput("architectures", json);

  rust-build:
    name: Build Rust code
    uses: ./.github/workflows/rust.yml
    secrets: inherit
    permissions:
      checks: write
      contents: read
      id-token: write
      pull-requests: write

  repo-has-container:
    name: Repo has container?
    runs-on: ubuntu-slim
    outputs:
      has_container: ${{ steps.determine.outputs.has_container }}
    steps:
      - name: Repo has docker container?
        shell: bash
        id: determine
        run: |
          has_container="${{ vars.HAS_CONTAINER }}"
          echo "has_container=${has_container:-false}" >> "${GITHUB_OUTPUT}"

  changes:
    name: Detect changes
    runs-on: ubuntu-slim
    permissions:
      contents: read
      pull-requests: read
    outputs:
      docker: ${{ steps.filter.outputs.docker }}
      rust: ${{ steps.filter.outputs.rust }}
    steps:
      - &checkout
        name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          show-progress: false

      - name: Check if we actually made changes
        uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36 # v3.0.2
        id: filter
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          filters: .github/file-filters.yml

  calculate-version:
    name: Calculate version
    runs-on: ubuntu-slim
    permissions:
      contents: read
    needs:
      - changes
      - repo-has-container
    outputs:
      version: ${{ steps.version.outputs.version }}
    if: |
      github.event_name == 'pull_request' &&
      fromJSON(needs.repo-has-container.outputs.has_container) == true &&
      (
        fromJSON(needs.changes.outputs.docker) == true ||
        fromJSON(needs.changes.outputs.rust) == true
      )
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          show-progress: false
          fetch-depth: 0

      - name: Install git-cliff to generate changelog & next version number
        uses: taiki-e/install-action@f176c07a0a40cbfdd08ee9aa8bf1655701d11e69 # v2.67.25
        with:
          tool: git-cliff

      - name: Calculate next version
        shell: bash
        id: version
        run: |
          version=$(git-cliff --bumped-version --unreleased --github-token ${{ secrets.GITHUB_TOKEN }})

          # remove v
          version="${version//v/}"

          # store
          echo "version=${version}" >> "${GITHUB_OUTPUT}"

  docker-prepare-variables:
    name: Prepare Docker variables and version bump patch
    runs-on: ubuntu-latest
    outputs:
      application_name: ${{ steps.variables.outputs.application_name }}
      description: ${{ steps.variables.outputs.description }}
      full_image_name_remote_registry: ${{ steps.variables.outputs.full_image_name_remote_registry }}
      full_image_name_local_registry: ${{ steps.variables.outputs.full_image_name_local_registry }}
      registry: ${{ steps.variables.outputs.registry }}
      unique_tag: ${{ steps.variables.outputs.unique_tag }}
    needs:
      - repo-has-container
      - calculate-version
    if: fromJSON(needs.repo-has-container.outputs.has_container) == true
    steps:
      - *checkout

      - &cache_cargo
        name: Cache cargo
        uses: actions/cache@cdf6c1fa76f9f475f3d7449005a359c84ca0f306 # v5.0.3
        env:
          CACHE_NAME: cargo
        with:
          path: |
            ~/.cargo/.crates.toml
            ~/.cargo/.crates2.json
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-${{ runner.arch }}-build-${{ env.CACHE_NAME }}-${{ hashFiles('Cargo.lock') }}-${{ github.job }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-build-${{ env.CACHE_NAME }}-${{ hashFiles('Cargo.lock') }}-
            ${{ runner.os }}-${{ runner.arch }}-build-${{ env.CACHE_NAME }}-

      - &set_up_mold
        name: Set up mold
        uses: rui314/setup-mold@725a8794d15fc7563f59595bd9556495c0564878 # v1

      - &set_up_toolchain
        name: Set up toolchain
        shell: bash
        run: |
          rm ${HOME}/.cargo/bin/cargo-fmt
          rm ${HOME}/.cargo/bin/rust-analyzer
          rm ${HOME}/.cargo/bin/rustfmt

          rustup self update
          rustup update
          rustup show active-toolchain || rustup toolchain install
          rustup show

          cargo --version

      - name: Install cargo-edit to do set-version
        uses: taiki-e/install-action@f176c07a0a40cbfdd08ee9aa8bf1655701d11e69 # v2.67.25
        with:
          tool: cargo-edit

      - name: Update Cargo.toml's version
        shell: bash
        run: |
          cargo set-version ${{ needs.calculate-version.outputs.version }}

          git diff

      - name: Store version bump diff
        shell: bash
        run: |
          git diff > /tmp/version-bump.patch

      - name: Upload version bump patch
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          if-no-files-found: error
          name: version-bump-patch
          path: /tmp/version-bump.patch
          retention-days: 1

      - name: Variables
        shell: bash
        id: variables
        run: |
          # The application name, used in the Dockerfile
          application_name=${{ env.IMAGE_NAME }}
          # split at the last / and keep that (kristof-mattei/repo-name -> repo-name)
          application_name=${application_name##*/}
          # lowercase
          application_name=${application_name,,}
          echo "application_name=${application_name}" >> "${GITHUB_OUTPUT}"

          # The application's description, from Cargo.toml
          description=$(cargo metadata --format-version 1 --no-deps | jq ".packages.[] | select(.name == \"${application_name}\") | .description" --raw-output)
          printf "%s\n" \
              "description<<EOF" \
              "$description" \
              "EOF" >> "$GITHUB_OUTPUT"

          # This is the unique docker tag
          unique_tag=pr-${{ github.event.pull_request.base.sha }}-${{ github.event.pull_request.head.sha }}
          echo "unique_tag=${unique_tag}" >> "${GITHUB_OUTPUT}"

          # The registry to which we'll push
          registry=${{ env.REGISTRY }}
          registry=${registry,,}
          echo "registry=${registry}" >> "${GITHUB_OUTPUT}"

          # The final full image name, which is the registry, the owner and the repo name
          image_name=${{ env.IMAGE_NAME }}
          image_name=${image_name,,}
          echo "full_image_name_remote_registry=${registry}/${image_name}" >> "${GITHUB_OUTPUT}"

          # The local registry to which we'll push
          local_registry=localhost:5000
          local_registry=${local_registry,,}
          echo "full_image_name_local_registry=${local_registry}/${image_name}" >> "${GITHUB_OUTPUT}"

  # this name is also used in `publish-crate-after-release.yml`
  docker-build:
    name: Build Docker container on ${{ matrix.runs-on }} for ${{ matrix.platform }}
    strategy:
      matrix:
        runs-on:
          - "ubuntu-latest"
          - "ubuntu-24.04-arm"
        platform: ${{ fromJSON(needs.architectures.outputs.architectures) }}
    runs-on: ${{ matrix.runs-on }}
    permissions:
      contents: read
      packages: write
    needs:
      - calculate-version
      - architectures
      - docker-prepare-variables
      - changes
      - repo-has-container
    if: |
      fromJSON(needs.repo-has-container.outputs.has_container) == true &&
      (
        fromJSON(needs.changes.outputs.docker) == true ||
        fromJSON(needs.changes.outputs.rust) == true
      )
    steps:
      - *checkout

      - name: Download version bump patch
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          name: version-bump-patch
          path: /tmp/

      - name: Apply version bump patch
        shell: bash
        run: |
          git apply /tmp/version-bump.patch

          echo "Applied patch:"
          git diff

      # TODO validate no changes between github.event.pull_request.head.sha and the actual current sha (representing the hypothetical merge)
      - name: Set variables
        shell: bash
        id: variables
        run: |
          # remove slashes from platform (`amd64/v3` -> `amd64-v3`)
          platform_no_slashes=${{ matrix.platform }}
          platform_no_slashes=${platform_no_slashes//\//-}
          echo "platform_no_slashes=${platform_no_slashes}" >> "${GITHUB_OUTPUT}"

          # but we're only building 1 arch here, so we need to identify that container (we'll merge them later)
          unique_tag_arch=${{ needs.docker-prepare-variables.outputs.unique_tag }}-${platform_no_slashes}
          echo "unique_tag_arch=${unique_tag_arch}" >> "${GITHUB_OUTPUT}"

      - name: Set up Docker
        uses: docker/setup-docker-action@e43656e248c0bd0647d3f5c195d116aacf6fcaf4 # v4.7.0
        with:
          daemon-config: |
            {
              "features": {
                "containerd-snapshotter": true
              }
            }

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0

      - name: Log into registry ${{ needs.docker-prepare-variables.outputs.registry }}
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          password: ${{ secrets.GITHUB_TOKEN }}
          registry: ${{ needs.docker-prepare-variables.outputs.registry }}
          username: ${{ github.actor }}

      - name: Should we set up QEMU?
        shell: bash
        id: setup_qemu
        run: |
          base_platform="${{ matrix.platform }}"

          if ! dpkg-architecture --equal "${base_platform%/*}"; then
            echo "setup_qemu=true" >> "${GITHUB_OUTPUT}"
          else
            echo "setup_qemu=false" >> "${GITHUB_OUTPUT}"
          fi

      - name: Set up QEMU
        uses: docker/setup-qemu-action@c7c53464625b32c7a7e944ae62b3e17d2b600130 # v3.7.0
        if: fromJSON(steps.setup_qemu.outputs.setup_qemu) == true
        with:
          platforms: linux/${{ matrix.platform }}

      - name: Extract Docker metadata
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5.10.0
        id: meta
        with:
          labels: |
            org.opencontainers.image.description=${{ needs.docker-prepare-variables.outputs.description }} (${{ matrix.platform }})
            org.opencontainers.image.revision=${{ github.event.pull_request.base.sha }}-${{ github.event.pull_request.head.sha }}
            org.opencontainers.image.source=${{ github.event.pull_request.html_url }}
            org.opencontainers.image.version=pr-${{ github.event.number }}
          images: ${{ needs.docker-prepare-variables.outputs.full_image_name_local_registry }}
          tags: |
            type=raw,value=${{ steps.variables.outputs.unique_tag_arch }}

      - name: Build Docker image
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          build-args: |
            APPLICATION_NAME=${{ needs.docker-prepare-variables.outputs.application_name }}
          context: .
          # this container is THE PR's artifact, and we will re-tag it
          # once the PR has been accepted
          cache-from: type=registry,ref=${{ needs.docker-prepare-variables.outputs.full_image_name_remote_registry }}-cache:${{ needs.docker-prepare-variables.outputs.application_name }}-buildcache-${{ runner.arch }}-${{ steps.variables.outputs.platform_no_slashes }}
          cache-to: type=registry,ref=${{ needs.docker-prepare-variables.outputs.full_image_name_remote_registry }}-cache:${{ needs.docker-prepare-variables.outputs.application_name }}-buildcache-${{ runner.arch }}-${{ steps.variables.outputs.platform_no_slashes }},mode=max
          labels: ${{ steps.meta.outputs.labels }}
          outputs: type=oci,dest=/tmp/${{ steps.variables.outputs.unique_tag_arch }}.tar
          platforms: linux/${{ matrix.platform }}
          tags: ${{ steps.meta.outputs.tags }}

      - name: Upload artifact
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        if: |
          matrix.runs-on == 'ubuntu-latest'
        with:
          if-no-files-found: error
          name: container-${{ needs.docker-prepare-variables.outputs.application_name }}-${{ steps.variables.outputs.platform_no_slashes }}
          path: /tmp/${{ steps.variables.outputs.unique_tag_arch }}.tar
          retention-days: 1

  docker-publish:
    name: Publish Docker container
    runs-on: ubuntu-latest
    services:
      registry:
        image: registry:3@sha256:6c5666b861f3505b116bb9aa9b25175e71210414bd010d92035ff64018f9457e
        ports:
          - 5000:5000
    outputs:
      digest: ${{ steps.local_image.outputs.digest }}
    permissions:
      packages: write
    needs:
      - docker-prepare-variables
      - docker-build
      - rust-build
    # Check if the event is not triggered by a fork
    if: |
      github.event.pull_request.head.repo.full_name == github.repository &&
      github.event_name == 'pull_request'
    steps:
      - name: Set up Docker
        uses: docker/setup-docker-action@e43656e248c0bd0647d3f5c195d116aacf6fcaf4 # v4.7.0
        with:
          daemon-config: |
            {
              "features": {
                "containerd-snapshotter": true
              }
            }

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0

      - name: Log into registry ${{ needs.docker-prepare-variables.outputs.registry }}
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          registry: ${{ needs.docker-prepare-variables.outputs.registry }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5.10.0
        id: meta
        with:
          images: ${{ needs.docker-prepare-variables.outputs.full_image_name_remote_registry }}
          labels: |
            org.opencontainers.image.description=${{ needs.docker-prepare-variables.outputs.description }}
            org.opencontainers.image.revision=${{ github.event.pull_request.base.sha }}-${{ github.event.pull_request.head.sha }}
            org.opencontainers.image.source=${{ github.event.pull_request.html_url }}
            org.opencontainers.image.version=pr-${{ github.event.number }}
          tags: |
            type=raw,value=${{ needs.docker-prepare-variables.outputs.unique_tag }}
            type=ref,event=pr,suffix=-latest

      - name: Download artifacts
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        id: artifact
        with:
          merge-multiple: true
          path: /tmp/container/
          pattern: container-${{ needs.docker-prepare-variables.outputs.application_name }}-*

      - name: Load individual platform images from artifacts & push to registry
        shell: bash
        working-directory: ${{ steps.artifact.outputs.download-path }}
        run: |
          platforms=()
          while IFS= read -r platform; do
            echo "Loading ${platform//\//-}:"
            docker load --input ./${{ needs.docker-prepare-variables.outputs.unique_tag }}-${platform//\//-}.tar

            full_name_with_platform=${{ needs.docker-prepare-variables.outputs.full_image_name_local_registry }}:${{ needs.docker-prepare-variables.outputs.unique_tag }}-${platform//\//-}

            echo "Pushing ${platform//\//-}:"
            docker push "$full_name_with_platform"

            platforms+=("$full_name_with_platform")
          done <<< "${{ env.IMAGE_VARIANTS }}"

          new_labels=()
          while IFS= read -r label; do
            new_labels+=(--annotation)
            new_labels+=("index:${label}")
          done <<< "${{ steps.meta.outputs.labels }}"

          # merge the platform containers in a new multiplatform one
          # with the new labels, and push it to our local registry
          docker buildx imagetools create "${new_labels[@]}" --tag "${{ needs.docker-prepare-variables.outputs.full_image_name_local_registry }}:${{ needs.docker-prepare-variables.outputs.unique_tag }}" \
            "${platforms[@]}"

          echo "Inspecting ${{ needs.docker-prepare-variables.outputs.full_image_name_local_registry }}:${{ needs.docker-prepare-variables.outputs.unique_tag }}:"
          docker buildx imagetools inspect --raw "${{ needs.docker-prepare-variables.outputs.full_image_name_local_registry }}:${{ needs.docker-prepare-variables.outputs.unique_tag }}"

      - name: Get digest of image in our local registry
        shell: bash
        id: local_image
        run: |
          digest=$(docker buildx imagetools inspect "${{ needs.docker-prepare-variables.outputs.full_image_name_local_registry }}:${{ needs.docker-prepare-variables.outputs.unique_tag }}" --format "{{json .}}" | jq --raw-output ".manifest.digest")

          echo "digest=${digest}" >> "${GITHUB_OUTPUT}"

      - name: Push from local registry to remote with new tags
        shell: bash
        run: |
          new_tags=()
          while IFS= read -r tag; do
            new_tags+=(--tag)
            new_tags+=("${tag}")
          done <<< "${{ steps.meta.outputs.tags }}"

          until timeout --kill-after=70 60 docker buildx imagetools create "${new_tags[@]}" \
            "${{ needs.docker-prepare-variables.outputs.full_image_name_local_registry }}:${{ needs.docker-prepare-variables.outputs.unique_tag }}"; do
            echo "Timeout exceeded / command failed, trying again..."

            sleep 2
          done

      - name: Inspect new remote tags
        shell: bash
        run: |
          while IFS= read -r new_tag; do
            echo "Inspecting ${new_tag}:"

            until timeout --kill-after=70 60 docker buildx imagetools inspect --raw "${new_tag}"; do
              echo "Timeout exceeded / command failed, trying again..."

              sleep 2
            done

            # empty to get newline
            echo ""
          done <<< "${{ steps.meta.outputs.tags }}"

  docker-attest:
    name: Attest Docker container
    runs-on: ubuntu-latest
    permissions:
      artifact-metadata: write
      attestations: write
      id-token: write
      packages: write
    needs:
      - docker-prepare-variables
      - docker-build
      - docker-publish
    # Check if the event is not triggered by a fork
    if: |
      github.event.pull_request.head.repo.full_name == github.repository &&
      github.event_name == 'pull_request'
    steps:
      - name: Set up Docker
        uses: docker/setup-docker-action@e43656e248c0bd0647d3f5c195d116aacf6fcaf4 # v4.7.0
        with:
          daemon-config: |
            {
              "features": {
                "containerd-snapshotter": true
              }
            }

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0

      - name: Log into registry ${{ needs.docker-prepare-variables.outputs.registry }}
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          registry: ${{ needs.docker-prepare-variables.outputs.registry }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # note that we use the digest of the local image
      # these digests don't change after pushing, but
      # since we deal with tags (mutable), and the way to get a digest is to use the tag, I prefer
      # sourcing the digest from the local registry we just spun up (trusted)
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@96278af6caaf10aea03fd8d33a09a777ca52d62f # v3.2.0
        id: attestation
        with:
          subject-name: ${{ needs.docker-prepare-variables.outputs.full_image_name_remote_registry }}
          subject-digest: ${{ needs.docker-publish.outputs.digest }}
          push-to-registry: true

  all-done:
    name: All done
    # this is the job that should be marked as required on GitHub. It's the only one that'll reliably trigger
    # when any upstream fails: success
    # when all upstream skips: pass
    # when all upstream success: success
    # combination of upstream skip and success: success
    runs-on: ubuntu-slim
    needs:
      - docker-prepare-variables
      - rust-build
      - docker-build
      - docker-publish
      - docker-attest
    if: |
      !cancelled()
    steps:
      - name: Fail!
        shell: bash
        if: |
          contains(needs.*.result, 'failure') ||
          contains(needs.*.result, 'cancelled')
        run: |
          echo "One / more upstream failed or was cancelled. Failing job..."

          exit 1

      - name: Success!
        shell: bash
        run: |
          echo "Great success!"
